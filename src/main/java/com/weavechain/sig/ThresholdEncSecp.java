package com.weavechain.sig;

import com.codahale.shamir.Scheme;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.spec.ECParameterSpec;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.custom.sec.SecP256K1Curve;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.ECGenParameterSpec;
import java.security.spec.KeySpec;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class ThresholdEncSecp {

    private static final boolean DEFAULT_USE_SHAMIR = false;

    private final int t;

    private final int n;

    private final Scheme scheme;

    private final boolean useShamir;

    private static final BigInteger ORDER = new SecP256K1Curve().getOrder();

    private static final String CURVE_TYPE = "secp256k1";

    private static final ECParameterSpec CURVE_SPEC = ECNamedCurveTable.getParameterSpec(CURVE_TYPE);

    private static final Object syncObj = new Object();

    private static final ThreadLocal<Map<Set<Integer>, List<BigInteger>>> cachedCoef = ThreadLocal.withInitial(ConcurrentHashMap::new);

    private static final int MAX_LEN = 33;

    private static final String KEY_FACTORY = "PBKDF2WithHmacSHA256";

    private static final String ALGORITHM = "ChaCha20-Poly1305";

    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(SecureRandom::new);

    public static SecureRandom random() {
        return RANDOM.get();
    }

    public ThresholdEncSecp(int t, int n) {
        this(t, n, DEFAULT_USE_SHAMIR);
    }

    public ThresholdEncSecp(int t, int n, boolean useShamir) {
        this.t = t;
        this.n = n;
        this.useShamir = useShamir;
        this.scheme = useShamir ? new Scheme(random(), n, t) : null;
    }

    public static BigInteger getBigInt(PrivateKey key) {
        if (key instanceof BCECPrivateKey) {
            return new BigInteger(1, ((BCECPrivateKey) key).getD().toByteArray());
        } else {
            return key != null ? new BigInteger(1, key.getEncoded()) : null;
        }
    }

    KeyPair generateKeys() throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException {
        KeyPairGenerator kpg = KeyPairGenerator.getInstance("ECDH", BouncyCastleProvider.PROVIDER_NAME);
        kpg.initialize(new ECGenParameterSpec(CURVE_TYPE));
        return kpg.generateKeyPair();
    }

    public ThresholdEncSecpParams generate(PrivateKey privateKey) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException {
        BigInteger pk = getBigInt(privateKey != null ? privateKey : generateKeys().getPrivate());
        ECPoint publicKey = CURVE_SPEC.getG().multiply(pk).normalize();

        List<byte[]> privateShares = new ArrayList<>();
        List<byte[]> publicShares = new ArrayList<>();

        List<BigInteger> c = new ArrayList<>();

        c.add(pk);
        for (int i = 1; i < t; i++) {
            c.add(new BigInteger(ORDER.bitLength(), random()).add(pk).mod(ORDER));
        }

        //private shares generated by a trusted dealer might not be ok certain use cases
        if (useShamir) {
            privateShares.addAll(scheme.split(pk.toByteArray()).values());
        } else {
            for (int j = 1; j <= n; j++) {
                BigInteger sum = BigInteger.ZERO;
                for (int i = 0; i < t; i++) {
                    sum = sum.add(c.get(i).multiply(BigInteger.valueOf(j).pow(i)));
                }
                BigInteger priv = sum.mod(ORDER);
                privateShares.add(priv.toByteArray());
            }
        }

        for (int i = 0; i < t; i++) {
            publicShares.add(CURVE_SPEC.getG().multiply(c.get(i)).normalize().getEncoded(true));
        }

        return new ThresholdEncSecpParams(
                pk.toByteArray(),
                publicKey.getEncoded(true),
                privateShares,
                publicShares
        );
    }

    public static boolean verify(byte[] privateShare, int index, List<byte[]> publicShares) {
        return verify(privateShare, index, publicShares, DEFAULT_USE_SHAMIR);
    }

    public static boolean verify(byte[] privateShare, int index, List<byte[]> publicShares, boolean useShamir) {
        if (useShamir) {
            return true;
        }

        if (publicShares.isEmpty()) {
            return false;
        }

        ECPoint check = CURVE_SPEC.getCurve().decodePoint(publicShares.get(0));
        for (int i = 1; i < publicShares.size(); i++) {
            ECPoint point = CURVE_SPEC.getCurve().decodePoint(publicShares.get(i));
            check = check.add(point.multiply(BigInteger.valueOf(index).pow(i + 1)).normalize());
        }

        ECPoint target = CURVE_SPEC.getG().multiply(new BigInteger(1, privateShare));
        return check.equals(target);
    }

    public byte[] reconstruct(List<byte[]> privateShares, Set<Integer> nodes) {
        if (useShamir) {
            Map<Integer, byte[]> parts = new TreeMap<>();
            int i = 1;
            for (byte[] it : privateShares) {
                parts.put(i++, it);
            }
            return new BigInteger(1, scheme.join(parts)).toByteArray();
        } else {
            BigInteger privateKey = BigInteger.ZERO;
            List<BigInteger> coef = getLagrangeCoef(n, nodes);

            List<Integer> sortedNodes = new ArrayList<>(nodes);
            Collections.sort(sortedNodes);

            int size = privateShares.size();
            for (int i = 0; i < size; i++) {
                int index = sortedNodes.get(i);
                BigInteger val = new BigInteger(1, privateShares.get(i)).multiply(coef.get(index));
                privateKey = privateKey.add(val).mod(ORDER);
            }
            return privateKey.mod(ORDER).toByteArray();
        }
    }

    public static List<BigInteger> getLagrangeCoef(int size, Set<Integer> nodes) {
        List<BigInteger> coef = cachedCoef.get().get(nodes);
        if (coef != null) {
            return coef;
        }

        List<BigInteger> lagrangeCoef = new ArrayList<>();
        for (int i = 1; i <= size; i++) {
            lagrangeCoef.add(BigInteger.ONE);
        }

        for (int i = 1; i <= size; i++) {
            BigInteger prodDiff = BigInteger.ONE;
            BigInteger factor = BigInteger.ONE;
            for (int j = 1; j <= size; j++) {
                if (i != j && nodes.contains(j - 1)) {
                    BigInteger dx = BigInteger.valueOf(j - i);
                    factor = factor.multiply(BigInteger.valueOf(j));
                    prodDiff = prodDiff.multiply(dx).mod(ORDER);
                }
            }

            BigInteger inv = prodDiff.modInverse(ORDER);
            lagrangeCoef.set(i - 1, factor.multiply(inv).mod(ORDER));
        }

        synchronized (syncObj) {
            cachedCoef.get().put(nodes, lagrangeCoef);
        }
        return lagrangeCoef;
    }

    private static void serialize(byte[] data, ByteArrayOutputStream output) throws IOException {
        output.write(shortBytes((short)data.length));
        output.write(data);
    }

    private static byte[] shortBytes(short value) {
        ByteBuffer longBuffer = ByteBuffer.allocate(Short.BYTES);
        longBuffer.order(ByteOrder.LITTLE_ENDIAN);
        longBuffer.putShort(value);
        return longBuffer.array();
    }

    public static byte[] encrypt(byte[] publicKey, BigInteger value) throws IOException {
        BigInteger k = new BigInteger(ORDER.bitLength(), random()).mod(ORDER);
        ECPoint P = CURVE_SPEC.getG().multiply(k).normalize();
        ECPoint pub = CURVE_SPEC.getCurve().decodePoint(publicKey);
        ECPoint H = pub.multiply(k).normalize();
        BigInteger enc = value.multiply(H.getYCoord().toBigInteger()).mod(ORDER);

        ByteArrayOutputStream result = new ByteArrayOutputStream();
        serialize(P.getEncoded(true), result);
        serialize(enc.toByteArray(), result);
        return result.toByteArray();
    }

    public static BigInteger decrypt(byte[] privateKey, byte[] data) {
        ByteBuffer buffer = ByteBuffer.wrap(data);
        buffer.order(ByteOrder.LITTLE_ENDIAN);

        ECPoint P = null;
        while (buffer.hasRemaining()) {
            int len = buffer.getShort();
            if (len <= MAX_LEN) {
                byte[] chunk = new byte[len];
                buffer.get(chunk);

                if (P == null) {
                    P = CURVE_SPEC.getCurve().decodePoint(chunk);
                } else {
                    BigInteger enc = new BigInteger(1, chunk);

                    ECPoint H = P.multiply(new BigInteger(1, privateKey)).normalize();
                    return enc.multiply(H.getYCoord().toBigInteger().modInverse(ORDER)).mod(ORDER);
                }
            }
        }

        return null;
    }

    public static byte[] encrypt(byte[] publicKey, String value) throws IllegalArgumentException {
        try {
            byte[] salt = new byte[32];
            random().nextBytes(salt);
            salt = get32Bytes(new BigInteger(salt).abs().mod(ORDER).toByteArray());

            SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_FACTORY);
            KeySpec spec = new PBEKeySpec(null, salt, 65536, 256);
            SecretKey tmp = factory.generateSecret(spec);
            SecretKeySpec secretKey = new SecretKeySpec(tmp.getEncoded(), ALGORITHM);
            Cipher cipher = Cipher.getInstance(ALGORITHM);

            byte[] iv = new byte[12];
            random().nextBytes(iv);
            IvParameterSpec ivspec = new IvParameterSpec(iv);

            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivspec);
            byte[] enc = cipher.doFinal(value.getBytes(StandardCharsets.UTF_8));

            BigInteger k = new BigInteger(ORDER.bitLength(), random()).mod(ORDER);
            ECPoint P = CURVE_SPEC.getG().multiply(k).normalize();
            ECPoint pub = CURVE_SPEC.getCurve().decodePoint(publicKey);
            ECPoint H = pub.multiply(k).normalize();

            ByteArrayOutputStream result = new ByteArrayOutputStream();
            result.write(iv);
            serialize(P.getEncoded(true), result);

            BigInteger v = new BigInteger(salt);
            BigInteger encoded = v.multiply(H.getYCoord().toBigInteger()).mod(ORDER);
            serialize(encoded.toByteArray(), result);

            result.write(enc);

            return result.toByteArray();
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
    }

    private static byte[] get32Bytes(byte[] bytes) {
        if (bytes.length == 33) {
            bytes = Arrays.copyOfRange(bytes, 1, bytes.length);
        } else if (bytes.length < 32) {
            byte[] out = new byte[32];
            System.arraycopy(bytes, 0, out, 32 - bytes.length, bytes.length);
            bytes = out;
        }
        return bytes;
    }

    public static String decryptString(byte[] privateKey, byte[] data) throws IOException {
        try {
            ByteArrayOutputStream result = new ByteArrayOutputStream();

            ByteBuffer buffer = ByteBuffer.wrap(data);
            buffer.order(ByteOrder.LITTLE_ENDIAN);

            byte[] iv = new byte[12];
            buffer.get(iv);

            ECPoint P = null;
            while (buffer.hasRemaining()) {
                int len = buffer.getShort();
                if (len <= MAX_LEN) {
                    byte[] chunk = new byte[len];
                    buffer.get(chunk);

                    if (P == null) {
                        P = CURVE_SPEC.getCurve().decodePoint(chunk);
                    } else {
                        BigInteger enc = new BigInteger(1, chunk);

                        ECPoint H = P.multiply(new BigInteger(1, privateKey)).normalize();
                        BigInteger val = enc.multiply(H.getYCoord().toBigInteger().modInverse(ORDER)).mod(ORDER);
                        result.write(get32Bytes(val.toByteArray()));
                        break;
                    }
                }
            }

            ByteBuffer input = ByteBuffer.wrap(result.toByteArray());
            byte[] salt = new byte[input.remaining()];
            input.get(salt);

            byte[] encoded = new byte[buffer.remaining()];
            buffer.get(encoded);

            IvParameterSpec ivspec = new IvParameterSpec(iv);

            SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_FACTORY);
            KeySpec spec = new PBEKeySpec(null, salt, 65536, 256);
            SecretKey tmp = factory.generateSecret(spec);
            SecretKeySpec secretKey = new SecretKeySpec(tmp.getEncoded(), ALGORITHM);

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivspec);

            return new String(cipher.doFinal(encoded), StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
    }
}