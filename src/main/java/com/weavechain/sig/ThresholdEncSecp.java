package com.weavechain.sig;

import com.codahale.shamir.Scheme;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.spec.ECParameterSpec;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.custom.sec.SecP256K1Curve;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.ECGenParameterSpec;
import java.util.*;

public class ThresholdEncSecp {

    private static final boolean DEFAULT_USE_SHAMIR = false;

    private static final int CHUNK_SIZE = 31;

    private final int t;

    private final int n;

    private final Scheme scheme;

    private final boolean useShamir;

    private static final BigInteger ORDER = new SecP256K1Curve().getOrder();

    private static final String CURVE_TYPE = "secp256k1";

    private static final ECParameterSpec CURVE_SPEC = ECNamedCurveTable.getParameterSpec(CURVE_TYPE);

    private static final Object syncObj = new Object();

    private static List<BigInteger> cachedCoef;

    private static int cachedSize;

    private static final int MAX_LEN = 512 * 1024 * 1024;

    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(SecureRandom::new);

    public static SecureRandom random() {
        return RANDOM.get();
    }

    public ThresholdEncSecp(int t, int n) {
        this(t, n, DEFAULT_USE_SHAMIR);
    }

    public ThresholdEncSecp(int t, int n, boolean useShamir) {
        this.t = t;
        this.n = n;
        this.useShamir = useShamir;
        this.scheme = useShamir ? new Scheme(random(), n, t) : null;
    }

    public static BigInteger getBigInt(PrivateKey key) {
        if (key instanceof BCECPrivateKey) {
            return new BigInteger(((BCECPrivateKey) key).getD().toByteArray());
        } else {
            return key != null ? new BigInteger(key.getEncoded()) : null;
        }
    }

    KeyPair generateKeys() throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException {
        KeyPairGenerator kpg = KeyPairGenerator.getInstance("ECDH", BouncyCastleProvider.PROVIDER_NAME);
        kpg.initialize(new ECGenParameterSpec(CURVE_TYPE));
        return kpg.generateKeyPair();
    }

    public ThresholdEncSecpParams generate(PrivateKey privateKey) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException {
        BigInteger pk = getBigInt(privateKey != null ? privateKey : generateKeys().getPrivate());
        ECPoint publicKey = CURVE_SPEC.getG().multiply(pk).normalize();

        List<byte[]> privateShares = new ArrayList<>();
        List<byte[]> publicShares = new ArrayList<>();

        List<BigInteger> c = new ArrayList<>();

        c.add(pk);
        for (int i = 1; i < t; i++) {
            c.add(new BigInteger(ORDER.bitLength(), random()).add(pk).mod(ORDER));
        }

        //private shares generated by a trusted dealer might not be ok certain use cases
        if (useShamir) {
            privateShares.addAll(scheme.split(pk.toByteArray()).values());
        } else {
            for (int j = 1; j <= n; j++) {
                BigInteger sum = BigInteger.ZERO;
                for (int i = 0; i < t; i++) {
                    sum = sum.add(c.get(i).multiply(BigInteger.valueOf(j).pow(i)));
                }
                BigInteger priv = sum.mod(ORDER);
                privateShares.add(priv.toByteArray());
            }
        }

        for (int i = 0; i < t; i++) {
            publicShares.add(CURVE_SPEC.getG().multiply(c.get(i)).normalize().getEncoded(true));
        }

        return new ThresholdEncSecpParams(
                pk.toByteArray(),
                publicKey.getEncoded(true),
                privateShares,
                publicShares
        );
    }

    public static boolean verify(byte[] privateShare, int index, List<byte[]> publicShares) {
        return verify(privateShare, index, publicShares, DEFAULT_USE_SHAMIR);
    }

    public static boolean verify(byte[] privateShare, int index, List<byte[]> publicShares, boolean useShamir) {
        if (useShamir) {
            return true;
        }

        if (publicShares.isEmpty()) {
            return false;
        }

        ECPoint check = CURVE_SPEC.getCurve().decodePoint(publicShares.get(0));
        for (int i = 1; i < publicShares.size(); i++) {
            ECPoint point = CURVE_SPEC.getCurve().decodePoint(publicShares.get(i));
            check = check.add(point.multiply(BigInteger.valueOf(index).pow(i + 1)).normalize());
        }

        ECPoint target = CURVE_SPEC.getG().multiply(new BigInteger(1, privateShare));
        return check.equals(target);
    }

    public byte[] reconstruct(List<byte[]> privateShares) {
        if (useShamir) {
            Map<Integer, byte[]> parts = new TreeMap<>();
            int i = 1;
            for (byte[] it : privateShares) {
                parts.put(i++, it);
            }
            return new BigInteger(1, scheme.join(parts)).toByteArray();
        } else {
            BigInteger privateKey = BigInteger.ZERO;
            int size = privateShares.size();
            List<BigInteger> coef = getLagrangeCoef(size);
            for (int i = 1; i <= size; i++) {
                privateKey = privateKey.add(new BigInteger(1, privateShares.get(i - 1)).multiply(coef.get(i - 1))).mod(ORDER);
            }
            return privateKey.mod(ORDER).toByteArray();
        }
    }

    public static List<BigInteger> getLagrangeCoef(int size) {
        if (cachedCoef != null && cachedSize >= size) {
            return cachedCoef;
        }

        List<BigInteger> lagrangeCoef = new ArrayList<>();
        for (int i = 1; i <= size; i++) {
            BigDecimal m = BigDecimal.ONE;
            for (int j = 1; j <= size; j++) {
                if (i != j) {
                    m = m.multiply(BigDecimal.valueOf(j * 1.0 / (j - i)));
                }
            }
            lagrangeCoef.add(m.toBigInteger());
        }

        synchronized (syncObj) {
            if (cachedSize < size) {
                cachedCoef = lagrangeCoef;
                cachedSize = size;
            }
        }
        return lagrangeCoef;
    }

    private static void serialize(byte[] data, ByteArrayOutputStream output) throws IOException {
        output.write(longBytes(data.length));
        output.write(data);
    }

    private static byte[] longBytes(long value) {
        ByteBuffer longBuffer = ByteBuffer.allocate(Long.BYTES);
        longBuffer.order(ByteOrder.LITTLE_ENDIAN);
        longBuffer.putLong(value);
        return longBuffer.array();
    }

    public static byte[] encrypt(byte[] publicKey, String value) throws IOException {
        byte[] data = value.getBytes(StandardCharsets.UTF_8);

        List<byte[]> chunks = new ArrayList<>();
        for (int i = 0; i < data.length; i += CHUNK_SIZE) {
            chunks.add(Arrays.copyOfRange(data, i, Math.min(i + CHUNK_SIZE, data.length)));
        }

        BigInteger k = new BigInteger(ORDER.bitLength(), random()).mod(ORDER);
        ECPoint P = CURVE_SPEC.getG().multiply(k).normalize();
        ECPoint pub = CURVE_SPEC.getCurve().decodePoint(publicKey);
        ECPoint H = pub.multiply(k).normalize();

        ByteArrayOutputStream result = new ByteArrayOutputStream();
        serialize(P.getEncoded(true), result);
        for (byte[] chunk : chunks) {
            BigInteger v = new BigInteger(1, chunk);
            BigInteger enc = v.multiply(H.getYCoord().toBigInteger()).mod(ORDER);
            serialize(enc.toByteArray(), result);
        }
        return result.toByteArray();
    }

    public static byte[] encrypt(byte[] publicKey, BigInteger value) throws IOException {
        BigInteger k = new BigInteger(ORDER.bitLength(), random()).mod(ORDER);
        ECPoint P = CURVE_SPEC.getG().multiply(k).normalize();
        ECPoint pub = CURVE_SPEC.getCurve().decodePoint(publicKey);
        ECPoint H = pub.multiply(k).normalize();
        BigInteger enc = value.multiply(H.getYCoord().toBigInteger()).mod(ORDER);

        ByteArrayOutputStream result = new ByteArrayOutputStream();
        serialize(P.getEncoded(true), result);
        serialize(enc.toByteArray(), result);
        return result.toByteArray();
    }

    public static BigInteger decrypt(byte[] privateKey, byte[] data) {
        ByteBuffer buffer = ByteBuffer.wrap(data);
        buffer.order(ByteOrder.LITTLE_ENDIAN);

        ECPoint P = null;
        while (buffer.hasRemaining()) {
            int len = (int) buffer.getLong();
            if (len < MAX_LEN) {
                byte[] chunk = new byte[len];
                buffer.get(chunk);

                if (P == null) {
                    P = CURVE_SPEC.getCurve().decodePoint(chunk);
                } else {
                    BigInteger enc = new BigInteger(chunk);

                    ECPoint H = P.multiply(new BigInteger(1, privateKey)).normalize();
                    return enc.multiply(H.getYCoord().toBigInteger().modInverse(ORDER)).mod(ORDER);
                }
            }
        }

        return null;
    }

    public static String decryptString(byte[] privateKey, byte[] data) throws IOException {
        ByteArrayOutputStream result = new ByteArrayOutputStream();

        ByteBuffer buffer = ByteBuffer.wrap(data);
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        ECPoint P = null;
        while (buffer.hasRemaining()) {
            int len = (int) buffer.getLong();
            if (len < MAX_LEN) {
                byte[] chunk = new byte[len];
                buffer.get(chunk);

                if (P == null) {
                    P = CURVE_SPEC.getCurve().decodePoint(chunk);
                } else {
                    BigInteger enc = new BigInteger(chunk);

                    ECPoint H = P.multiply(new BigInteger(1, privateKey)).normalize();
                    BigInteger val = enc.multiply(H.getYCoord().toBigInteger().modInverse(ORDER)).mod(ORDER);
                    result.write(val.toByteArray());

                }
            }
        }

        return result.toString(StandardCharsets.UTF_8);
    }
}